
/**
 * Implements core functions of the meal planner. Contains an ArrayList of Week
 * containing all weeks in the meal planner.
 * 
 * Provides methods to persist data across program executions, including loading
 * existing data from a CSV file, and saving current data to a CSV file
 * (overwriting its contents). Also contains methods that allow the user
 * to interact with the meal planner by adding/removing weeks, meals, and 
 * ingredients, and changing ingredient quantities. Additionally, methods are 
 * included to print/summarize a given week or a given day, and to print a 
 * shopping list of ingredients in alphabetical order.
 * 
 * @author Michel Pr√©jet
 * @version 2025-09-07
 */

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;

public class MealPlanner {
    private ArrayList<Week> weeklyPlans;

    public static final String EMPTY_PLACEHOLDER = "_EMPTY_";
    private static final int COL_WIDTH = 16;
    private static final int LINE_WIDTH = (COL_WIDTH + 1) * Week.getDaysOfWeek().length;

    /**
     * Constructs a new Meal Planner with an empty Week ArrayList.
     */
    public MealPlanner() {
        this.weeklyPlans = new ArrayList<>();
    }

    /**
     * @param weekAnchorDate the anchor date of the week to be returned.
     * @return the week in the meal planner with the given anchor date, or null
     *         if no such week exists.
     * @throws ValidationException if {@code weekAnchorDate} is null,
     *                             empty, or only whitespace.
     */
    public Week getWeek(String weekAnchorDate) {
        DataValidator.validateString(weekAnchorDate, "Week anchor date");

        for (Week week : this.weeklyPlans) {
            if (week.getAnchorDate().equals(weekAnchorDate)) {
                return week;
            }
        }
        return null;
    }

    /**
     * Loads weeks, days, meals, and ingredients from a CSV file with a given name
     * and stores them in the meal planner. Reads each line and creates/retrieves
     * the appropriate week, day, meal, and/or ingredient in/from the weeklyPlans
     * ArrayList. Assumes the CSV file has a header and that each line is formatted
     * as WeekAnchorDate,DayOfWeek,MealName,IngredientName,Quantity,CarbsPer100g,
     * FatPer100g,ProteinPer100g, where the last three fields are optional (can be
     * omitted) and all fields except for the first can be ignored if they contain
     * the placeholder "_EMPTY_". However, as soon as the placeholder is
     * encountered,
     * the rest of the line is skipped.
     * Malformed lines are skipped entirely, but should not occur since the data
     * file is generated by the program, not the user.
     * 
     * @param filename the name of the CSV file containing data.
     * @throws ValidationException if the file name is null, empty, or only
     *                             whitespace.
     */
    public void loadDataFromCSV(String filename) {
        DataValidator.validateString(filename, "File name");

        try (BufferedReader br = new BufferedReader(new FileReader(filename))) {
            String line = br.readLine();
            line = br.readLine(); // Skip header.
            while (line != null) {
                if (DataValidator.validateLine(line)) {
                    String[] tokens = line.split(",");

                    // Create new week, meal, and ingredient objects.
                    Week week = new Week(tokens[0]);
                    Meal meal = null;
                    Ingredient ing = null;
                    if (!tokens[2].equals(EMPTY_PLACEHOLDER)) {
                        meal = new Meal(tokens[2]);

                        if (!tokens[3].equals(EMPTY_PLACEHOLDER) && !tokens[4].equals(EMPTY_PLACEHOLDER)) {
                            if (tokens.length == 5) {
                                ing = new Ingredient(tokens[3], Double.parseDouble(tokens[4]));
                            } else {
                                ing = new Ingredient(tokens[3], Double.parseDouble(tokens[4]),
                                        Double.parseDouble(tokens[5]),
                                        Double.parseDouble(tokens[6]), Double.parseDouble(tokens[7]));
                            }
                        }
                    }

                    // Add the new week to the weeklyPlans ArrayList, or retrieve it
                    // if it already exists.
                    if (!this.weeklyPlans.contains(week)) {
                        this.weeklyPlans.add(week);
                    } else {
                        week = Week.getWeekByAnchor(this.weeklyPlans, week.getAnchorDate());
                    }

                    // Add the new meal to the correct day, or retrieve it if it
                    // already exists.
                    Day day = null;
                    if (!tokens[1].equals(EMPTY_PLACEHOLDER)) {
                        day = week.getDay(tokens[1]);

                        if (meal != null) {
                            if (!day.getMeals().contains(meal)) {
                                day.addMeal(meal);
                            } else {
                                meal = day.getMeal(meal);
                            }
                        }
                    }

                    // Add the new ingredient to the meal if it doesn't already
                    // exist.
                    if (meal != null && ing != null && !meal.getIngredients().contains(ing)) {
                        meal.addIngredient(ing);
                    }
                }

                line = br.readLine();
            }
        } catch (IOException e) {
            System.out.println(e);
        }
    }

    /**
     * Writes all data contained in the weeklyPlans ArrayList to a CSV file with
     * a given name. This includes all weeks, days, meals, and ingredients. The
     * CSV file has a header and is formatted as WeekAnchorDate,DayOfWeek,MealName,
     * IngredientName,Quantity,CarbsPer100g,FatPer100g,ProteinPer100g, where the
     * last three fields are optional. All fields except for the first can also be
     * omitted and replaced with the placeholder "_EMPTY_". Allows for data to
     * persist after the program terminates.
     * 
     * @param filename the name of the CSV file to write to.
     * @throws ValidationException if the file name is null, empty, or only
     *                             whitespace.
     */
    public void writeDataToCSV(String filename) {
        DataValidator.validateString(filename, "File name");

        try (PrintWriter pw = new PrintWriter(new File(filename))) {
            pw.println(
                    "WeekAnchorDate,DayOfWeek,MealName,IngredientName,Quantity,CarbsPer100g,FatPer100g,ProteinPer100g");

            for (Week week : this.weeklyPlans) {
                boolean containsMeals = false;

                for (int i = 0; i < Week.getDaysOfWeek().length; i++) {
                    for (Meal meal : week.getDay(i).getMeals()) {
                        containsMeals = true;
                        boolean containsIngredients = false;

                        for (Ingredient ing : meal.getIngredients()) {
                            containsIngredients = true;

                            // Print with no placeholders.
                            if (ing.hasNutrition()) {
                                pw.printf("%s,%s,%s,%s,%f,%f,%f,%f\n", week.getAnchorDate(), Week.getDaysOfWeek()[i],
                                        meal.getName(), ing.getName(), ing.getQuantity(), ing.getCarbsPer100Grams(),
                                        ing.getFatPer100Grams(), ing.getProteinPer100Grams());
                            } else {
                                pw.printf("%s,%s,%s,%s,%f\n", week.getAnchorDate(), Week.getDaysOfWeek()[i],
                                        meal.getName(), ing.getName(), ing.getQuantity());
                            }
                        }

                        // Print with placeholders for ingredient info if there were no ingredients in
                        // the meal.
                        if (!containsIngredients) {
                            pw.printf("%s,%s,%s,%s,%s\n", week.getAnchorDate(), Week.getDaysOfWeek()[i],
                                    meal.getName(), EMPTY_PLACEHOLDER, EMPTY_PLACEHOLDER);
                        }
                    }
                }

                // Print with placeholders for meal info if there were no meals in the week.
                if (!containsMeals) {
                    pw.printf("%s,%s,%s,%s,%s\n", week.getAnchorDate(), EMPTY_PLACEHOLDER,
                            EMPTY_PLACEHOLDER, EMPTY_PLACEHOLDER, EMPTY_PLACEHOLDER);
                }
            }
        } catch (IOException e) {
            System.out.println(e);
        }
    }

    /**
     * @param weekAnchorDate the anchor date of the week to be added to the meal
     *                       planner.
     * @throws ValidationException if {@code weekAnchorDate} is not a valid
     *                             date of the form YYYY-MM-DD or if
     *                             {@code weekAnchorDate} already exists in
     *                             the meal planner.
     */
    public void addWeek(String weekAnchorDate) {
        Week toAdd = new Week(weekAnchorDate);
        if (this.weeklyPlans.contains(toAdd)) {
            throw new ValidationException("Week", ValidationException.ALREADY_EXISTS_CODE);
        }

        weeklyPlans.add(toAdd);
    }

    /**
     * @param weekAnchorDate the anchor date of the week to be removed from the meal
     *                       planner.
     * @throws ValidationException if {@code weekAnchorDate} is not a valid date of
     *                             the form YYYY-MM-DD, or if the corresponding week
     *                             is not in the meal planner.
     */
    public void removeWeek(String weekAnchorDate) {
        DataValidator.validateDate(weekAnchorDate, "Week anchor date");

        if (!weeklyPlans.remove(new Week(weekAnchorDate))) {
            throw new ValidationException("Week", ValidationException.DOESNT_EXIST_CODE);
        }
    }

    /**
     * @param weekAnchorDate the anchor date of the week to which the meal should
     *                       be added.
     * @param dayOfWeek      the day of the week to which the meal should be added.
     * @param mealName       the name of the meal to be added.
     * @return the meal that was added, or null if no meal was successfully added.
     * @throws ValidationException if {@code weekAnchorDate} is not valid date of
     *                             the form YYYY-MM-DD, if any of the arguments
     *                             are null, empty, or whitespace only, if
     *                             {@code dayOfWeek} is not a valid day of the week,
     *                             or if a meal with the given name already exists.
     * 
     */
    public Meal addMeal(String weekAnchorDate, String dayOfWeek, String mealName) {
        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = new Meal(mealName);

        if (!day.getMeals().contains(meal)) {
            day.addMeal(meal);
        } else {
            throw new ValidationException("Meal name", ValidationException.ALREADY_EXISTS_CODE);
        }

        return meal;
    }

    /**
     * @param weekAnchorDate the anchor date of the week in which the meal is
     *                       found.
     * @param dayOfWeek      the day of the week to in which the meal is found.
     * @param mealName       the name of the meal to be removed.
     * @throws ValidationException if any of the arguments are null, empty, or
     *                             whitespace only, if {@code weekAnchorDate} isn't
     *                             a valid date of the form YYYY-MM-DD, if
     *                             {@code dayOfWeek} is not a valid day of the week,
     *                             or if the meal with {@code mealName} doesn't
     *                             exist in the specified day.
     */
    public void removeMeal(String weekAnchorDate, String dayOfWeek, String mealName) {
        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        day.removeMeal(new Meal(mealName));
    }

    /**
     * @param weekAnchorDate the anchor date of the week to which the ingredient
     *                       should be added.
     * @param dayOfWeek      the day of the week to which the ingredient should be
     *                       added.
     * @param mealName       the name of the meal to which the ingredient should
     *                       be added.
     * @param ingredientName the name of the ingredient to be added.
     * @param quantity       the quantity of the ingredient to be added.
     * @throws ValidationException if any of the arguments are null, empty, or
     *                             whitespace only, if {@code weekAnchorDate} is not
     *                             a valid date of the form YYYY-MM-DD, if
     *                             {@code dayOfWeek} is not a valid day of the week,
     *                             if {@code quantity} is not a valid decimal value,
     *                             or if the ingredient with the name
     *                             {@code ingredientName} already exists in the
     *                             specified meal.
     */
    public void addIngredient(String weekAnchorDate, String dayOfWeek, String mealName, String ingredientName,
            String quantity) {
        DataValidator.requireDouble(quantity, "Ingredient quantity");
        Double quantityParsed = Double.parseDouble(quantity);

        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));
        Ingredient ing = new Ingredient(ingredientName, quantityParsed);

        meal.addIngredient(ing);
    }

    /**
     * @param weekAnchorDate the anchor date of the week to which the ingredient
     *                       should be added.
     * @param dayOfWeek      the day of the week to which the ingredient should be
     *                       added.
     * @param mealName       the name of the meal to which the ingredient should
     *                       be added.
     * @param ingredientName the name of the ingredient to be added.
     * @param quantity       the quantity of the ingredient to be added.
     * @param carbsPer100    the amount of carbohydrates per 100 grams of the
     *                       ingredient to be added.
     * @param fatPer100      the amount of fat per 100 grams of the ingredient to be
     *                       added.
     * @param proteinPer100  the amount of protein per 100 grams of the ingredient
     *                       to be added.
     * @throws ValidationException if any of the arguments are null, empty, or
     *                             whitespace only, if {@code weekAnchorDate} is not
     *                             a valid date of the form YYYY-MM-DD, if
     *                             {@code dayOfWeek} is not a valid day of the week,
     *                             if {@code quantity} or macronutrient amounts are
     *                             not valid decimal values, or if the ingredient
     *                             with the name {@code ingredientName} already
     *                             exists in the specified meal.
     */
    public void addIngredient(String weekAnchorDate, String dayOfWeek, String mealName, String ingredientName,
            String quantity, String carbsPer100, String fatPer100, String proteinPer100) {
        DataValidator.requireDouble(quantity, "Ingredient quantity");
        DataValidator.requireDouble(carbsPer100, "Carbohydrates per 100 grams");
        DataValidator.requireDouble(fatPer100, "Fat per 100 grams");
        DataValidator.requireDouble(proteinPer100, "Protein per 100 grams");

        double quantityParsed = Double.parseDouble(quantity);
        double carbsParsed = Double.parseDouble(carbsPer100);
        double fatParsed = Double.parseDouble(fatPer100);
        double proteinParsed = Double.parseDouble(proteinPer100);

        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));
        Ingredient ing = new Ingredient(ingredientName, quantityParsed, carbsParsed,
                fatParsed, proteinParsed);

        meal.addIngredient(ing);
    }

    /**
     * @param weekAnchorDate the anchor date of the week in which the ingredient
     *                       is found.
     * @param dayOfWeek      the day of the week in which the ingredient is found.
     * @param mealName       the name of the meal in which the ingredient is found.
     * @param ingredientName the name of the ingredient for which the quantity
     *                       should be modified.
     * @param newQuantity    the new quantity of the ingredient.
     * @throws ValidationException if any of the arguments are null, empty, or
     *                             whitespace only, if {@code weekAnchorDate} is not
     *                             a valid date of the form YYYY-MM-DD, if
     *                             {@code dayOfWeek} is not a valid day of the week,
     *                             or if {@code newQuantity} is not a valid decimal
     *                             value.
     */
    public void changeIngredientQuantity(String weekAnchorDate, String dayOfWeek, String mealName,
            String ingredientName, String newQuantity) {
        DataValidator.requireDouble(newQuantity, "New ingredient quantity");
        Double newQuantityParsed = Double.parseDouble(newQuantity);

        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));
        Ingredient ing = meal.getIngredient(ingredientName);

        ing.setQuantity(newQuantityParsed);
    }

    /**
     * @param weekAnchorDate the anchor date of the week in which the ingredient
     *                       is found.
     * @param dayOfWeek      the day of the week in which the ingredient is found.
     * @param mealName       the name of the meal in which the ingredient is found.
     * @param ingredientName the name of the ingredient to be removed.
     * @throws ValidationException if any of the arguments are null, empty, or
     *                             whitespace only, if {@code weekAnchorDate} is not
     *                             a valid date of the form YYYY-MM-DD, if
     *                             {@code dayOfWeek} is not a valid day of the week,
     *                             or if {@code ingredientName} doesn't correspond
     *                             to an ingredient in the specified meal.
     */
    public void removeIngredient(String weekAnchorDate, String dayOfWeek, String mealName,
            String ingredientName) {
        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));
        Ingredient ing = meal.getIngredient(ingredientName);

        meal.removeIngredient(ing);
    }

    /**
     * @param weekAnchorDate the anchor date of the week for which all ingredients
     *                       should be returned.
     * @return an ArrayList of Ingredient containing all ingredients for the week
     *         with {@code weekAnchorDate}.
     * @throws ValidationException if {@code weekAnchorDate} is not a valid
     *                             date of the form YYYY-MM-DD.
     * 
     */
    public ArrayList<Ingredient> getWeekIngredientList(String weekAnchorDate) {
        Week week = getWeek(weekAnchorDate);
        return week.getAllIngredients();
    }

    /**
     * Prints a list of all weeks in this meal planner sorted in ascending
     * order by anchor date.
     */
    public void printAllWeeks() {
        ArrayList<Week> sortedWeeks = sortWeeks();
        String output = "\nAvailable weeks:";
        for (Week week : sortedWeeks) {
            output += "\nWeek of " + formatDate(week.getAnchorDate());
        }
        System.out.println(output);
    }

    /**
     * @param weekAnchorDate the anchor date of the week to be printed.
     * @return a tabular representation of the week with {@code weekAnchorDate},
     *         including meals and their Calorie counts, average daily
     *         Calories intake, average daily carbohydrate consumption, average
     *         daily fat consumption, and average daily protein consumption.
     * @throws ValidationException if {@code weekAnchorDate} is not a valid date
     *                             of the form YYYY-MM-DD.
     */
    public void printWeek(String weekAnchorDate) {
        Week week = getWeek(weekAnchorDate);

        // Add header.
        String output = String.format("\nWeek of %s\n", formatDate(weekAnchorDate));
        for (String dayOfWeek : Week.getDaysOfWeek()) {
            output += String.format("%-" + COL_WIDTH + "s|", fitCell(dayOfWeek));
        }
        output += "\n";
        for (int i = 0; i < LINE_WIDTH; i++) {
            output += "-";
        }
        output += "\n";

        // Add meals and ingredients for each day of the week.
        String[][] rows = getRowsToPrint(week);
        for (int i = 0; i < rows.length; i++) {
            for (int j = 0; j < rows[i].length; j++) {
                output += String.format("%-" + COL_WIDTH + "s|", fitCell(rows[i][j]));
            }
            output += "\n";
        }

        for (int i = 0; i < LINE_WIDTH; i++) {
            output += "-";
        }
        output += "\n";

        // Add week statistics.
        output += String.format("Average daily Calorie intake: %.2f kcal\n", week.getAvgCaloriesPerDay());
        output += String.format("Average daily carbohydrate consumption: %.2f g\n", week.getAvgCarbsPerDay());
        output += String.format("Average daily fat consumption: %.2f g\n", week.getAvgFatPerDay());
        output += String.format("Average daily protein consumption: %.2f g\n", week.getAvgProteinPerDay());

        System.out.print(output);
    }

    /**
     * Prints a summary of a given day of a week with a given anchor date,
     * including daily nutritional information and a list of meals with their
     * respective nutritional information and ingredients.
     * 
     * @param weekAnchorDate the anchor date of the target week.
     * @param dayOfWeek      the name of the target day (e.g. Friday).
     * @throws ValidationException if {@code weekAnchorDate} is not a valid date
     *                             of the form YYYY-MM-DD or if {@code dayOfWeek} is
     *                             not a valid day of the week.
     */
    public void printDay(String weekAnchorDate, String dayOfWeek) {
        Week week = getWeek(weekAnchorDate);
        Day day = week.getDay(dayOfWeek);

        // Add header, including week, day of week, and a daily nutritional summary.
        String output = String.format("\n%s (week of %s)", dayOfWeek, formatDate(weekAnchorDate));
        output += String.format("\n%.2f kcal | %.2f g carbs | %.2f g fat | %.2f g protein",
                day.getCalories(), day.getCarbsTotal(), day.getFatTotal(), day.getProteinTotal());

        // Add all meals for the given day and their ingredients.
        for (Meal meal : day.getMeals()) {
            if (meal.getIngredients().size() > 0) {
                output += String.format("\n\n\t%s (%.2f kcal, %.2f g carbs, %.2f g fat, %.2f g protein)",
                        meal.getName(),
                        meal.getCalories(), meal.getCarbsTotal(), meal.getFatTotal(), meal.getProteinTotal());
                for (Ingredient ing : meal.getIngredients()) {
                    output += String.format("\n\t\t- %s (%.2f g)", ing.getName(), ing.getQuantity());
                }
            } else {
                output += String.format("\n\n\t%s (No nutritional profile)", meal.getName());
            }
        }

        System.out.println(output);
    }

    /**
     * Prints a meal given a week anchor date, a day of the week, and a meal
     * name, using the corresponding meal's overridden toString() method, if
     * such a meal exists.
     * 
     * @param weekAnchorDate the anchor date of the week in which the meal is
     *                       found.
     * @param dayOfWeek      the day of the week in which the meal is found.
     * @param mealName       the name of the meal to be printed.
     * @throws ValidationException if {@code weekAnchorDate} is not a valid
     *                             date of the form YYYY-MM-DD, if {@code dayOfWeek}
     *                             is not a valid day of the week, or if
     *                             {@code mealName} is null, empty, or whitespace
     *                             only.
     */
    public void printMeal(String weekAnchorDate, String dayOfWeek, String mealName) {
        Week week = getWeek(weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));

        System.out.println(meal);
    }

    /**
     * Prints an ingredient given a week anchor date, a day of the week, a meal
     * name, and an ingredient name, using the corresponding ingredient's
     * overridden toString() method, if such an ingredient exists.
     * 
     * @param weekAnchorDate the anchor date of the week in which the ingredient is
     *                       found.
     * @param dayOfWeek      the day of the week in which the ingredient is found.
     * @param mealName       the meal in which the ingredient is found.
     * @param ingName        the name of the ingredient to be printed.
     * @throws ValidationException if any arguments are null, empty, or whitespace
     *                             only, if {@code weekAnchorDate} is not a valid
     *                             date of the form YYYY-MM-DD, or if
     *                             {@code dayOfWeek} is not a valid day of the week.
     */
    public void printIngredient(String weekAnchorDate, String dayOfWeek, String mealName, String ingName) {
        Week week = getWeek(weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));
        Ingredient ing = meal.getIngredient(ingName);

        System.out.println(ing);
    }

    /**
     * Prints all ingredients required to prepare meals for a week with a given
     * anchor date. The list includes ingredient names and quantities and is
     * printed in alphabetical order (ascending).
     * 
     * @param weekAnchorDate the anchor date string for the target week.
     * @throws ValidationException if {@code weekAnchorDate} is not a valid date
     *                             of the form YYYY-MM-DD.
     */
    public void printShoppingList(String weekAnchorDate) {
        Week week = getWeek(weekAnchorDate);
        ArrayList<Ingredient> list = sortIngredients(week.getAllIngredients());
        System.out.printf("\nShopping list for the week of %s:", formatDate(weekAnchorDate));
        for (Ingredient ing : list) {
            System.out.printf("\n\t- %s (%.2f g)", ing.getName(), ing.getQuantity());
        }
        System.out.println();
    }

    @Override
    public String toString() {
        String output = "";
        for (Week week : this.weeklyPlans) {
            output += week.toString() + "\n";
        }
        return output;
    }

    /**
     * Builds a 2D string grid used to print a weekly meal table.
     * 
     * @param week the week for which the grid should be built.
     * @return a 2D array of String containing meal names at even indices and
     *         Calorie values and odd indices.
     */
    private String[][] getRowsToPrint(Week week) {
        int maxRows = getMaxNumRows(week);
        String[][] result = new String[maxRows][Week.getDaysOfWeek().length];

        int mealCount = 0;
        int row = 0;
        while (mealCount < maxRows / 3) {
            for (int i = 0; i < Week.getDaysOfWeek().length; i++) {
                Day currDay = week.getDay(Week.getDaysOfWeek()[i]);
                ArrayList<Meal> meals = currDay.getMeals();

                if (mealCount < meals.size()) {
                    result[row][i] = meals.get(mealCount).getName();
                    result[row + 1][i] = String.format("%.2f kcal", meals.get(mealCount).getCalories());
                    result[row + 2][i] = "";
                } else {
                    result[row][i] = "";
                    result[row + 1][i] = "";
                    result[row + 2][i] = "";
                }
            }

            mealCount++;
            row += 3;
        }

        return result;
    }

    /**
     * Determines the maximum number of rows to be printed for a given week.
     * Finds the day of the week with the greatest number of meals, then
     * multiplies that number by three (since each meal requires three rows: one
     * for its name, one for its Calorie count, and one blank line).
     * 
     * @param week the week for which the maximum number of rows to print should
     *             be determined.
     * @return the maximum number of rows to print for the given week.
     */
    private int getMaxNumRows(Week week) {
        int max = 0;
        for (int i = 0; i < Week.getDaysOfWeek().length; i++) {
            Day curr = week.getDay(Week.getDaysOfWeek()[i]);
            int count = curr.getMeals().size() * 3;
            if (count > max) {
                max = count;
            }
        }
        return max;
    }

    /**
     * Allows a given string to fit into a cell of a table by truncating it
     * and replacing the truncated characters by "...". The length of the
     * cell is equal to COL_WIDTH.
     * 
     * @param s the string to be formatted to fit into a cell.
     * @return a truncated string with "..." replacing truncated characters, or
     *         the original string if its length did not exceed the cell length,
     *         or a truncated string without "..." if the cell length is less
     *         than 4.
     */
    private String fitCell(String s) {
        final int DOTS_WIDTH = 3;

        if (s.length() <= COL_WIDTH) {
            return s;
        }

        if (COL_WIDTH < DOTS_WIDTH + 1) {
            return s.substring(0, COL_WIDTH);
        }

        return s.substring(0, COL_WIDTH - DOTS_WIDTH) + "...";
    }

    /**
     * @param date a date of the form YYYY-MM-DD to be formatted.
     * @return a date of the form Month DayNumber, YearNumber (e.g. January 1,
     *         2000).
     * @throws ValidationException if {@code date} is not a valid date of the
     *                             form YYYY-MM-DD.
     */
    private String formatDate(String date) {
        String[] dateTokens = Week.getDateFromString(date);
        return String.format("%s %d, %d", dateTokens[1], Integer.parseInt(dateTokens[2]),
                Integer.parseInt(dateTokens[0]));
    }

    /**
     * Sorts an ArrayList of Ingredient in ascending order via merge sort. Uses
     * Ingredient.compareTo(), which compares ingredients lexicographically by
     * name.
     * 
     * @param list the ArrayList of Ingredient to sort.
     * @return a new ArrayList of Ingredient containing the elements of the given
     *         list sorted in ascending order by name.
     */
    private ArrayList<Ingredient> sortIngredients(ArrayList<Ingredient> list) {
        if (list.size() <= 1) {
            return new ArrayList<>(list);
        }

        int mid = list.size() / 2;
        ArrayList<Ingredient> left = new ArrayList<>(list.subList(0, mid));
        ArrayList<Ingredient> right = new ArrayList<>(list.subList(mid, list.size()));

        return mergeArr(sortIngredients(left), sortIngredients(right));
    }

    /**
     * Merges two sorted ArrayLists of Ingredient into a new list while preserving
     * sorted order.
     * 
     * @param a1 the first sorted ArrayList.
     * @param a2 the second sorted ArrayList.
     * @return a new ArrayList of Ingredient containing all elements of a1
     *         and a2 in ascending order.
     */
    private ArrayList<Ingredient> mergeArr(ArrayList<Ingredient> a1, ArrayList<Ingredient> a2) {
        int i = 0, j = 0;
        ArrayList<Ingredient> mergedArr = new ArrayList<Ingredient>(a1.size() + a2.size());

        while (i < a1.size() && j < a2.size()) {
            if (a1.get(i).compareTo(a2.get(j)) <= 0) {
                mergedArr.add(a1.get(i++));
            } else {
                mergedArr.add(a2.get(j++));
            }
        }

        while (i < a1.size()) {
            mergedArr.add(a1.get(i++));
        }
        while (j < a2.size()) {
            mergedArr.add(a2.get(j++));
        }

        return mergedArr;
    }

    /**
     * Sorts an ArrayList of Week in ascending order via selection sort. Uses
     * Week.compareTo(), which compares Weeks lexicographically by week anchor
     * date.
     * 
     * @return a new ArrayList of Week containing the elements of weeklyPlans
     *         sorted in ascending order by week anchor date.
     */
    private ArrayList<Week> sortWeeks() {
        ArrayList<Week> list = new ArrayList<>(this.weeklyPlans);

        if (list.size() <= 1) {
            return list;
        }

        for (int i = 0; i < list.size() - 1; i++) {

            // Find minimum in the unsorted sublist.
            int min = i;
            for (int j = i + 1; j < list.size(); j++) {
                if (list.get(j).compareTo(list.get(min)) < 0) {
                    min = j;
                }
            }

            // Move minimum to position i.
            if (min != i) {
                Week temp = list.remove(min);
                list.add(i, temp);
            }
        }

        return list;
    }

}