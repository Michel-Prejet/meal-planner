
/**
 * Implements core functions of the meal planner. Contains an ArrayList of Week
 * containing all weeks in the meal planner.
 * 
 * Provides methods to persist data across program executions, including loading
 * existing data from a CSV file, and saving current data to a CSV file
 * (overwriting its contents). Also contains methods that allow the user
 * to interact with the meal planner by adding/removing weeks, meals, and 
 * ingredients, and changing ingredient quantities. Additionally, methods are 
 * included to print/summarize a given week or a given day, and to print a 
 * shopping list of ingredients in alphabetical order.
 * 
 * @author Michel Pr√©jet
 * @version 2025-08-29
 */

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;

public class MealPlanner {
    private ArrayList<Week> weeklyPlans;
    private static final int DAYS_IN_WEEK = 7;
    private static final int COL_WIDTH = 16;
    private static final int LINE_WIDTH = (COL_WIDTH + 1) * DAYS_IN_WEEK;

    /**
     * Constructs a new Meal Planner with an empty Week ArrayList.
     */
    public MealPlanner() {
        this.weeklyPlans = new ArrayList<>();
    }

    /**
     * @param weekAnchorDate the anchor date of the week to be returned.
     * @return the week in the meal planner with the given anchor date, or null
     *         if no such week exists.
     */
    public Week getWeek(String weekAnchorDate) {
        for (Week week : this.weeklyPlans) {
            if (week.getAnchorDate().equals(weekAnchorDate)) {
                return week;
            }
        }
        return null;
    }

    /**
     * Loads weeks, days, meals, and ingredients from a CSV file with a given name
     * and stores them in the meal planner. Reads each line and creates/retrieves
     * the appropriate week, day, meal, and ingredient in/from the weeklyPlans
     * ArrayList. Assumes the CSV file has a header and that each line is formatted
     * as WeekAnchorDate,DayOfWeek,MealName,IngredientName,Quantity,CarbsPer100g,
     * FatPer100g,ProteinPer100g, where the last three fields are optional.
     * Malformed lines are skipped entirely, but should not occur since the data
     * file is generated by the program, not the user.
     * 
     * @param filename the name of the CSV file containing data.
     * @throws IllegalArgumentException if the file name is null, empty, or only
     *                                  whitespace.
     */
    public void loadDataFromCSV(String filename) {
        if (!DataValidator.validateString(filename)) {
            throw new IllegalArgumentException("File name cannot be null, empty, or only whitespace.");
        }

        try {
            BufferedReader br = new BufferedReader(new FileReader(filename));

            String line = br.readLine();
            line = br.readLine(); // Skip header.
            while (line != null) {
                if (DataValidator.validateLine(line)) {
                    String[] tokens = line.split(",");

                    // Create new week, meal, and ingredient objects.
                    Week week = new Week(tokens[0]);
                    Meal meal = new Meal(tokens[2]);
                    Ingredient ing;
                    if (tokens.length == 5) {
                        ing = new Ingredient(tokens[3], Double.parseDouble(tokens[4]));
                    } else {
                        ing = new Ingredient(tokens[3], Double.parseDouble(tokens[4]), Double.parseDouble(tokens[5]),
                                Double.parseDouble(tokens[6]), Double.parseDouble(tokens[7]));
                    }

                    // Add the new week to the weeklyPlans ArrayList, or retrieve it
                    // if it already exists.
                    if (!this.weeklyPlans.contains(week)) {
                        this.weeklyPlans.add(week);
                    } else {
                        week = Week.getWeekByAnchor(this.weeklyPlans, week.getAnchorDate());
                    }

                    // Add the new meal to the correct day, or retrieve it if it
                    // already exists.
                    Day day = week.getDay(tokens[1]);
                    if (!day.getMeals().contains(meal)) {
                        day.addMeal(meal);
                    } else {
                        meal = day.getMeal(meal);
                    }

                    // Add the new ingredient to the meal if it doesn't already
                    // exist.
                    meal.addIngredient(ing);

                }

                line = br.readLine();
            }

            br.close();
        } catch (IOException e) {
            System.out.println(e);
        }
    }

    /**
     * Writes all data contained in the weeklyPlans ArrayList to a CSV file with
     * a given name. This includes all weeks, days, meals, and ingredients. The
     * CSV file has a header and is formatted as WeekAnchorDate,DayOfWeek,MealName,
     * IngredientName,Quantity,CarbsPer100g,FatPer100g,ProteinPer100g, where the
     * last three fields are optional. Allows for data to persist after the program
     * terminates.
     * 
     * @param filename the name of the CSV file to write to.
     * @throws IllegalArgumentException if the file name is null, empty, or only
     *                                  whitespace.
     */
    public void writeDataToCSV(String filename) {
        if (!DataValidator.validateString(filename)) {
            throw new IllegalArgumentException("File name cannot be null, empty, or only whitespace.");
        }

        try {
            PrintWriter pw = new PrintWriter(new File(filename));
            pw.println(
                    "WeekAnchorDate,DayOfWeek,MealName,IngredientName,Quantity,CarbsPer100g,FatPer100g,ProteinPer100g");

            for (Week week : this.weeklyPlans) {
                for (int i = 0; i < DAYS_IN_WEEK; i++) {
                    for (Meal meal : week.getDay(i).getMeals()) {
                        for (Ingredient ing : meal.getIngredients()) {
                            if (ing.hasNutrition()) {
                                pw.printf("%s,%s,%s,%s,%f,%f,%f,%f\n", week.getAnchorDate(), Week.DAYS_OF_THE_WEEK[i],
                                        meal.getName(), ing.getName(), ing.getQuantity(), ing.getCarbsPer100Grams(),
                                        ing.getFatPer100Grams(), ing.getProteinPer100Grams());
                            } else {
                                pw.printf("%s,%s,%s,%s,%f\n", week.getAnchorDate(), Week.DAYS_OF_THE_WEEK[i],
                                        meal.getName(), ing.getName(), ing.getQuantity());
                            }
                        }
                    }
                }
            }

            pw.close();
        } catch (IOException e) {
            System.out.println(e);
        }
    }

    /**
     * @param weekAnchorDate the anchor date of the week to be added to the meal
     *                       planner.
     */
    public void addWeek(String weekAnchorDate) {
        if (!DataValidator.validateString(weekAnchorDate) || !DataValidator.validateDate(weekAnchorDate)) {
            System.out.println(
                    "[Error] Week not could not be added because the anchor date is invalid.");
            return;
        }

        Week toAdd = new Week(weekAnchorDate);
        if (this.weeklyPlans.contains(toAdd)) {
            System.out.println("[Error] Week could not be added because it already exists.");
            return;
        }
        weeklyPlans.add(toAdd);
        System.out.println(">> Added week of " + formatDate(toAdd.getAnchorDate()));
    }

    /**
     * @param weekAnchorDate the anchor date of the week to be removed from the meal
     *                       planner.
     */
    public void removeWeek(String weekAnchorDate) {
        if (!DataValidator.validateString(weekAnchorDate)) {
            System.out.println(
                    "[Error] Week could not be removed because the given anchor date is null, empty, or only whitespace.");
            return;
        }

        if (!weeklyPlans.remove(new Week(weekAnchorDate))) {
            System.out.println("[Error] Week could not be removed because it doesn't exist.");
        } else {
            System.out.println(">> Removed week of " + formatDate(weekAnchorDate));
        }
    }

    /**
     * @param weekAnchorDate the anchor date of the week to which the meal should
     *                       be added.
     * @param dayOfWeek      the day of the week to which the meal should be added.
     * @param mealName       the name of the meal to be added.
     * @return the meal that was added, or null if no meal was successfully added.
     */
    public Meal addMeal(String weekAnchorDate, String dayOfWeek, String mealName) {
        if (!DataValidator.validateString(mealName)) {
            System.out.println(
                    "[Error] Meal could not be added because the given name is null, empty, or only whitespace.");
            return null;
        }

        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = new Meal(mealName);

        if (day.getMeals().contains(meal)) {
            System.out.println("[Error] Meal could not be added because it already exists.");
            return null;
        }

        day.addMeal(meal);
        System.out.println(">> Added meal: " + meal.getName());
        return meal;
    }

    /**
     * @param weekAnchorDate the anchor date of the week in which the meal is
     *                       found.
     * @param dayOfWeek      the day of the week to in which the meal is found.
     * @param mealName       the name of the meal to be removed.
     */
    public void removeMeal(String weekAnchorDate, String dayOfWeek, String mealName) {
        if (!DataValidator.validateString(mealName)) {
            System.out.println(
                    "[Error] Meal could not be removed because the given name is null, empty, or only whitespace.");
            return;
        }

        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);
        Day day = week.getDay(dayOfWeek);

        if (!day.removeMeal(new Meal(mealName))) {
            System.out.println("[Error] Meal could not be removed because it doesn't exist.");
        } else {
            System.out.println(">> Removed meal: " + mealName);
        }
    }

    /**
     * @param weekAnchorDate the anchor date of the week to which the ingredient
     *                       should be added.
     * @param dayOfWeek      the day of the week to which the ingredient should be
     *                       added.
     * @param mealName       the name of the meal to which the ingredient should
     *                       be added.
     * @param ingredientName the name of the ingredient to be added.
     * @param quantity       the quantity of the ingredient to be added.
     */
    public void addIngredient(String weekAnchorDate, String dayOfWeek, String mealName, String ingredientName,
            String quantity) {
        if (!DataValidator.validateString(ingredientName)) {
            System.out.println(
                    "[Error] Could not add ingredient because the given name is null, empty, or only whitespace.");
            return;
        }

        if (!DataValidator.isValidDouble(quantity)) {
            System.out.println("[Error] Ingredient could not be added because the given quantity is invalid.");
            return;
        }

        Double quantityParsed = Double.parseDouble(quantity);
        if (quantityParsed <= 0) {
            System.out.println("[Error] Ingredient could not be added because the given quantity is zero or negative.");
            return;
        }

        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));
        Ingredient ing = new Ingredient(ingredientName, quantityParsed);

        if (meal.getIngredients().contains(ing)) {
            System.out.println("[Error] Ingredient could not be added because it already exists.");
            return;
        }

        meal.addIngredient(ing);
        System.out.println(">> Added ingredient: " + ing.getName());
    }

    /**
     * @param weekAnchorDate the anchor date of the week to which the ingredient
     *                       should be added.
     * @param dayOfWeek      the day of the week to which the ingredient should be
     *                       added.
     * @param mealName       the name of the meal to which the ingredient should
     *                       be added.
     * @param ingredientName the name of the ingredient to be added.
     * @param quantity       the quantity of the ingredient to be added.
     * @param carbsPer100    the amount of carbohydrates per 100 grams of the
     *                       ingredient to be added.
     * @param fatPer100      the amount of fat per 100 grams of the ingredient to be
     *                       added.
     * @param proteinPer100  the amount of protein per 100 grams of the ingredient
     *                       to be added.
     */
    public void addIngredient(String weekAnchorDate, String dayOfWeek, String mealName, String ingredientName,
            String quantity, String carbsPer100, String fatPer100, String proteinPer100) {
        if (DataValidator.validateString(ingredientName)) {
            System.out.println(
                    "[Error] Could not add ingredient because the given name is null, empty, or only whitespace.");
            return;
        }

        if (!DataValidator.isValidDouble(quantity) || !DataValidator.isValidDouble(carbsPer100)
                || !DataValidator.isValidDouble(fatPer100) || !DataValidator.isValidDouble(proteinPer100)) {
            System.out.println(
                    "[Error] Ingredient could not be added because the given quantity or macronutrient amounts are invalid.");
            return;
        }

        double quantityParsed = Double.parseDouble(quantity);
        double carbsParsed = Double.parseDouble(carbsPer100);
        double fatParsed = Double.parseDouble(fatPer100);
        double proteinParsed = Double.parseDouble(proteinPer100);

        if (quantityParsed <= 0 || carbsParsed < 0 || fatParsed < 0 || proteinParsed < 0) {
            System.out.println(
                    "[Error] Ingredient could not be added because the given quantity is zero negative, or the given macronutrient amounts are negative.");
            return;
        }

        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));
        Ingredient ing = new Ingredient(ingredientName, quantityParsed, carbsParsed,
                fatParsed, proteinParsed);

        if (meal.getIngredients().contains(ing)) {
            System.out.println("[Error] Ingredient could not be added because it already exists.");
            return;
        }

        meal.addIngredient(ing);
        System.out.println(">> Added ingredient: " + ing.getName());
    }

    /**
     * @param weekAnchorDate the anchor date of the week in which the ingredient
     *                       is found.
     * @param dayOfWeek      the day of the week in which the ingredient is found.
     * @param mealName       the name of the meal in which the ingredient is found.
     * @param ingredientName the name of the ingredient for which the quantity
     *                       should be modified.
     * @param newQuantity    the new quantity of the ingredient.
     */
    public void changeIngredientQuantity(String weekAnchorDate, String dayOfWeek, String mealName,
            String ingredientName, String newQuantity) {
        if (!DataValidator.isValidDouble(newQuantity)) {
            System.out.println(
                    "[Error] Ingredient quantity could not be modified because the given quantity is not a valid number.");
            return;
        }
        Double newQuantityParsed = Double.parseDouble(newQuantity);
        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);

        if (newQuantityParsed <= 0) {
            System.out.println(
                    "[Error] Ingredient quantity could not be modified because the given quantity is zero or negative.");
            return;
        }

        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));
        Ingredient ing = meal.getIngredient(ingredientName);

        ing.setQuantity(newQuantityParsed);
        System.out.println(">> Modified ingredient quantity: " + ing.getName() + " -> " + newQuantityParsed + " g");
    }

    /**
     * @param weekAnchorDate the anchor date of the week in which the ingredient
     *                       is found.
     * @param dayOfWeek      the day of the week in which the ingredient is found.
     * @param mealName       the name of the meal in which the ingredient is found.
     * @param ingredientName the name of the ingredient to be removed.
     */
    public void removeIngredient(String weekAnchorDate, String dayOfWeek, String mealName,
            String ingredientName) {
        if (!DataValidator.validateString(ingredientName)) {
            System.out.println(
                    "[Error] Could not remove ingredient because the given name is null, empty, or only whitespace.");
            return;
        }

        Week week = Week.getWeekByAnchor(this.weeklyPlans, weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));
        Ingredient ing = meal.getIngredient(ingredientName);

        if (ing == null) {
            System.out.println("[Error] Ingredient could not be removed because it does not exist.");
            return;
        }

        meal.removeIngredient(ing);
        System.out.println(">> Removed ingredient: " + ing.getName());
    }

    /**
     * @param weekAnchorDate the anchor date of the week for which all ingredients
     *                       should be returned.
     * @return an ArrayList of Ingredient containing all ingredients for a week
     *         with a given anchor date.
     */
    public ArrayList<Ingredient> getWeekIngredientList(String weekAnchorDate) {
        Week week = getWeek(weekAnchorDate);
        return week.getAllIngredients();
    }

    /**
     * Prints a list of all weeks in this meal planner sorted in ascending
     * order by anchor date.
     */
    public void printAllWeeks() {
        ArrayList<Week> sortedWeeks = sortWeeks();
        String output = "\nAvailable weeks:";
        for (Week week : sortedWeeks) {
            output += "\nWeek of " + formatDate(week.getAnchorDate());
        }
        System.out.println(output);
    }

    /**
     * @param weekAnchorDate the anchor date of the week to be printed.
     * @return a tabular representation of the week with the given anchor
     *         date, including meals and their Calories counts, average daily
     *         Calories intake, average daily carbohydrate consumption, average
     *         daily fat consumption, and average daily protein consumption.
     */
    public void printWeek(String weekAnchorDate) {
        Week week = getWeek(weekAnchorDate);

        // Add header.
        String output = String.format("\nWeek of %s\n", formatDate(weekAnchorDate));
        for (String dayOfWeek : Week.DAYS_OF_THE_WEEK) {
            output += String.format("%-" + COL_WIDTH + "s|", fitCell(dayOfWeek));
        }
        output += "\n";
        for (int i = 0; i < LINE_WIDTH; i++) {
            output += "-";
        }
        output += "\n";

        // Add meals and ingredients for each day of the week.
        String[][] rows = getRowsToPrint(week);
        for (int i = 0; i < rows.length; i++) {
            for (int j = 0; j < rows[i].length; j++) {
                output += String.format("%-" + COL_WIDTH + "s|", fitCell(rows[i][j]));
            }
            output += "\n";
        }

        for (int i = 0; i < LINE_WIDTH; i++) {
            output += "-";
        }
        output += "\n";

        // Add week statistics.
        output += String.format("Average daily Calorie intake: %.2f kcal\n", week.getAvgCaloriesPerDay());
        output += String.format("Average daily carbohydrate consumption: %.2f g\n", week.getAvgCarbsPerDay());
        output += String.format("Average daily fat consumption: %.2f g\n", week.getAvgFatPerDay());
        output += String.format("Average daily protein consumption: %.2f g\n", week.getAvgProteinPerDay());

        System.out.print(output);
    }

    /**
     * Prints a summary of a given day of a week with a given anchor date,
     * including daily nutritional information and a list of meals with their
     * respective nutritional information and ingredients.
     * 
     * @param weekAnchorDate the anchor date of the target week.
     * @param dayOfWeek      the name of the target day (e.g. Friday).
     * @throws IllegalArgumentException if weekAnchorDate or dayOfWeek are null.
     */
    public void printDay(String weekAnchorDate, String dayOfWeek) {
        Week week = getWeek(weekAnchorDate);
        Day day = week.getDay(dayOfWeek);

        // Add header, including week, day of week, and a daily nutritional summary.
        String output = String.format("\n%s (week of %s)", dayOfWeek, formatDate(weekAnchorDate));
        output += String.format("\n%.2f kcal | %.2f g carbs | %.2f g fat | %.2f g protein",
                day.getCalories(), day.getCarbsTotal(), day.getFatTotal(), day.getProteinTotal());

        // Add all meals for the given day and their ingredients.
        for (Meal meal : day.getMeals()) {
            output += String.format("\n\n\t%s (%.2f kcal, %.2f g carbs, %.2f g fat, %.2f g protein)", meal.getName(),
                    meal.getCalories(), meal.getCarbsTotal(), meal.getFatTotal(), meal.getProteinTotal());
            for (Ingredient ing : meal.getIngredients()) {
                output += String.format("\n\t\t- %s (%.2f g)", ing.getName(), ing.getQuantity());
            }
        }

        System.out.println(output);
    }

    /**
     * Prints a meal given a week anchor date, a day of the week, and a meal
     * name, using the corresponding meal's overridden toString() method, if
     * such a meal exists.
     * 
     * @param weekAnchorDate the anchor date of the week in which the meal is
     *                       found.
     * @param dayOfWeek      the day of the week in which the meal is found.
     * @param mealName       the name of the meal to be printed.
     * @throws IllegalArgumentException if weekAnchorDate, dayOfWeek, or mealName
     *                                  are null.
     */
    public void printMeal(String weekAnchorDate, String dayOfWeek, String mealName) {
        Week week = getWeek(weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));

        System.out.println(meal);
    }

    /**
     * Prints an ingredient given a week anchor date, a day of the week, a meal
     * name, and an ingredient name, using the corresponding ingredient's
     * overridden toString() method, if such an ingredient exists.
     * 
     * @param weekAnchorDate the anchor date of the week in which the ingredient is
     *                       found.
     * @param dayOfWeek      the day of the week in which the ingredient is found.
     * @param mealName       the meal in which the ingredient is found.
     * @param ingName        the name of the ingredient to be printed.
     * @throws IllegalArgumentException if weekAnchorDate, dayOfWeek, mealName,
     *                                  or ingName are null.
     */
    public void printIngredient(String weekAnchorDate, String dayOfWeek, String mealName, String ingName) {
        Week week = getWeek(weekAnchorDate);
        Day day = week.getDay(dayOfWeek);
        Meal meal = day.getMeal(new Meal(mealName));
        Ingredient ing = meal.getIngredient(ingName);

        System.out.println(ing);
    }

    /**
     * Prints all ingredients required to prepare meals for a week with a given
     * anchor date. The list includes ingredient names and quantities and is
     * printed in alphabetical order (ascending).
     * 
     * @param weekAnchorDate the anchor date string for the target week.
     * @throws IllegalArgumentException if the given anchor date is null.
     */
    public void printShoppingList(String weekAnchorDate) {
        if (weekAnchorDate == null) {
            throw new IllegalArgumentException("Week anchor date cannot be null.");
        }

        Week week = getWeek(weekAnchorDate);
        ArrayList<Ingredient> list = sortIngredients(week.getAllIngredients());
        System.out.printf("\nShopping list for the week of %s:", formatDate(weekAnchorDate));
        for (Ingredient ing : list) {
            System.out.printf("\n\t- %s (%.2f g)", ing.getName(), ing.getQuantity());
        }
    }

    @Override
    public String toString() {
        String output = "";
        for (Week week : this.weeklyPlans) {
            output += week.toString() + "\n";
        }
        return output;
    }

    /**
     * Builds a 2D string grid used to print a weekly meal table.
     * 
     * @param week the week for which the grid should be built.
     * @return a 2D array of String containing meal names at even indices and
     *         Calorie values and odd indices.
     */
    private String[][] getRowsToPrint(Week week) {
        int maxRows = getMaxNumRows(week);
        String[][] result = new String[maxRows][DAYS_IN_WEEK];

        int mealCount = 0;
        int row = 0;
        while (mealCount < maxRows / 3) {
            for (int i = 0; i < DAYS_IN_WEEK; i++) {
                Day currDay = week.getDay(Week.DAYS_OF_THE_WEEK[i]);
                ArrayList<Meal> meals = currDay.getMeals();

                if (mealCount < meals.size()) {
                    result[row][i] = meals.get(mealCount).getName();
                    result[row + 1][i] = String.format("%.2f kcal", meals.get(mealCount).getCalories());
                    result[row + 2][i] = "";
                } else {
                    result[row][i] = "";
                    result[row + 1][i] = "";
                    result[row + 2][i] = "";
                }
            }

            mealCount++;
            row += 3;
        }

        return result;
    }

    /**
     * Determines the maximum number of rows to be printed for a given week.
     * Finds the day of the week with the greatest number of meals, then
     * multiplies that number by three (since each meal requires three rows: one
     * for its name, one for its Calorie count, and one blank line).
     * 
     * @param week the week for which the maximum number of rows to print should
     *             be determined.
     * @return the maximum number of rows to print for the given week.
     */
    private int getMaxNumRows(Week week) {
        int max = 0;
        for (int i = 0; i < DAYS_IN_WEEK; i++) {
            Day curr = week.getDay(Week.DAYS_OF_THE_WEEK[i]);
            int count = curr.getMeals().size() * 3;
            if (count > max) {
                max = count;
            }
        }
        return max;
    }

    /**
     * Allows a given string to fit into a cell of a table by truncating it
     * and replacing the truncated characters by "...". The length of the
     * cell is equal to COL_WIDTH.
     * 
     * @param s the string to be formatted to fit into a cell.
     * @return a truncated string with "..." replacing truncated characters, or
     *         the original string if its length did not exceed the cell length,
     *         or a truncated string without "..." if the cell length is less
     *         than 4.
     */
    private String fitCell(String s) {
        if (s == null) {
            throw new IllegalArgumentException("String to be fitted cannot be null.");
        }

        if (s.length() <= COL_WIDTH) {
            return s;
        }

        if (COL_WIDTH < 4) {
            return s.substring(0, COL_WIDTH);
        }

        return s.substring(0, COL_WIDTH - 3) + "...";
    }

    /**
     * @param date a date of the form YYYY-MM-DD to be formatted.
     * @return a date of the form Month DayNumber, YearNumber (e.g. January 1,
     *         2000).
     * @throws IllegalArgumentException if the given date is improperly formatted
     *                                  or invalid.
     */
    private String formatDate(String date) {
        if (!DataValidator.validateDate(date)) {
            throw new IllegalArgumentException("Could not format date because it is invalid.");
        }

        String[] dateTokens = Week.getDateFromString(date);
        return String.format("%s %d, %d", dateTokens[1], Integer.parseInt(dateTokens[2]),
                Integer.parseInt(dateTokens[0]));
    }

    /**
     * Sorts an ArrayList of Ingredient in ascending order via merge sort. Uses
     * Ingredient.compareTo(), which compares ingredients lexicographically by
     * name.
     * 
     * @param list the ArrayList of Ingredient to sort.
     * @return a new ArrayList of Ingredient containing the elements of the given
     *         list sorted in ascending order by name.
     * @throws IllegalArgumentException if the given list is null.
     */
    private ArrayList<Ingredient> sortIngredients(ArrayList<Ingredient> list) {
        if (list == null) {
            throw new IllegalArgumentException("Cannot sort a null ArrayList.");
        }

        if (list.size() <= 1) {
            return new ArrayList<>(list);
        }

        int mid = list.size() / 2;
        ArrayList<Ingredient> left = new ArrayList<>(list.subList(0, mid));
        ArrayList<Ingredient> right = new ArrayList<>(list.subList(mid, list.size()));

        return mergeArr(sortIngredients(left), sortIngredients(right));
    }

    /**
     * Merges two sorted ArrayLists of Ingredient into a new list while preserving
     * sorted order.
     * 
     * @param a1 the first sorted ArrayList.
     * @param a2 the second sorted ArrayList.
     * @return a new ArrayList of Ingredient containing all elements of a1
     *         and a2 in ascending order.
     * @throws IllegalArgumentException if either of a1 or a2 is null.
     */
    private ArrayList<Ingredient> mergeArr(ArrayList<Ingredient> a1, ArrayList<Ingredient> a2) {
        if (a1 == null || a2 == null) {
            throw new IllegalArgumentException("Cannot merge null ArrayLists.");
        }

        int i = 0, j = 0;
        ArrayList<Ingredient> mergedArr = new ArrayList<Ingredient>(a1.size() + a2.size());

        while (i < a1.size() && j < a2.size()) {
            if (a1.get(i).compareTo(a2.get(j)) <= 0) {
                mergedArr.add(a1.get(i++));
            } else {
                mergedArr.add(a2.get(j++));
            }
        }

        while (i < a1.size()) {
            mergedArr.add(a1.get(i++));
        }
        while (j < a2.size()) {
            mergedArr.add(a2.get(j++));
        }

        return mergedArr;
    }

    /**
     * Sorts an ArrayList of Week in ascending order via selection sort. Uses
     * Week.compareTo(), which compares Weeks lexicographically by week anchor
     * date.
     * 
     * @return a new ArrayList of Week containing the elements of weeklyPlans
     *         sorted in ascending order by week anchor date.
     */
    private ArrayList<Week> sortWeeks() {
        ArrayList<Week> list = new ArrayList<>(this.weeklyPlans);

        if (list.size() <= 1) {
            return list;
        }

        for (int i = 0; i < list.size() - 1; i++) {

            // Find minimum in the unsorted sublist.
            int min = i;
            for (int j = i + 1; j < list.size(); j++) {
                if (list.get(j).compareTo(list.get(min)) < 0) {
                    min = j;
                }
            }

            // Move minimum to position i.
            if (min != i) {
                Week temp = list.remove(min);
                list.add(i, temp);
            }
        }

        return list;
    }

}